import { BotError } from "../../../errors/bot-error.ts";
import { puppeteerInstance } from "../../../lib/puppeteer.ts";
import type { DownloadNovelOptions, IChapterData, INovelData } from "../../../types/bot.ts";
import { delay } from "../../../utils/delay.ts";
import { logger } from "../../../utils/logger.ts";
import { ThumbnailProcessor } from "../../download-thumbnail.ts";
import { processChaptersList } from "../../process-chapter-list.ts";
import { collectChapterList } from "./parse-html/collect-chapter-list.ts";
import { collectChapter } from "./parse-html/collect-chapter.ts";
import { collectNovelInfo } from "./parse-html/collect-novel-info.ts";

export const _getNovel = async (
  url: string,
  opt: DownloadNovelOptions
): Promise<INovelData> => {

  const LANGUAGE = 'english';
  const SOURCE = url;

  const puppeteer = await puppeteerInstance();

  // instancia o browser
  const browser = await puppeteer.launch({
    headless: true,
    args: [
      '--no-sandbox',
      '--disable-setuid-sandbox',
      '--disable-gpu',
      '--no-zygote',
      '--disable-software-rasterizer',
      '--disable-features=VizDisplayCompositor'
    ],
    timeout: 60000 * 4,
  });
  const page = await browser.newPage();

  // Navega até a pagina alvo
  await page.goto(url, { waitUntil: 'load' });
  await page.waitForSelector('h1');
  const novelInfo = await page.evaluate(collectNovelInfo);

  if (!novelInfo) {
    await browser.close()
    throw new BotError(
      'Unable to retrieve any information from the target page. Check if the URL used is correct'
    )
  }

  // download thumbnail To base64
  if (novelInfo.thumbnail) {
    const thumbnailProcessor = new ThumbnailProcessor(novelInfo.thumbnail);
    const thumbnail = await thumbnailProcessor.execute();
    novelInfo.thumbnail = thumbnail;
  }

  // Check if list chapters url is collected
  if (!novelInfo.chapterListPageUrl) {
    await browser.close()
    throw new BotError('Unable to retrieve chapter list page url')
  }


  await page.goto(novelInfo.chapterListPageUrl, { waitUntil: 'load' });
  const isChapterList = await page.waitForSelector('.list-chapter');

  if (!isChapterList) {
    await browser.close();
    throw new BotError('Unable to collect chapter list')
  }

  const chaptersList = await page.evaluate(collectChapterList);

  if (chaptersList.length === 0) {
    await browser.close();
    throw new BotError('The chapter list is empty, or it could not be retrieved')
  }

  await page.close()



  // Collect Chapters
  const chapters: IChapterData[] = [];
  await processChaptersList(chaptersList, async ({ url }, index) => {

    const onRequest = (req) => {
      const block = ['stylesheet', 'font', 'image', 'script']
      if (block.includes(req.resourceType())) {
        req.abort();
      } else {
        req.continue();
      }
    }


    const chapterPage = await browser.newPage()
    await chapterPage.setRequestInterception(true);

    // Wait 30s to next interaction and clear cookies
    if (index !== 0 && index % 100 === 0) {
      await delay(30000);
      logger.debug(`[DEBUG] Downloaded ${index} chapters. Waiting 30 seconds to avoid rate limits...`)

      // Remove all cookies generated by site
      const cookies = await browser.cookies();
      await browser.deleteCookie(...cookies);
    }

    // Block useless content
    chapterPage.on('request', onRequest)

    try {
      await chapterPage.goto(url, { timeout: 90000, waitUntil: 'domcontentloaded' });

      const title = await chapterPage.waitForSelector('h1', { timeout: 10000 });

      if (!title) {
        await chapterPage.reload()
        await chapterPage.waitForSelector('h1', { timeout: 10000 })
      }

      const result = await chapterPage.evaluate(collectChapter);

      if (!result) {
        chapterPage.off('request', onRequest)
        await chapterPage.close()
        throw new BotError('Failed to extract chapter')
      }


      chapters.push({
        title: result.title,
        content: result.content
      })

      if (!chapterPage.isClosed()) {
        chapterPage.off('request', onRequest)
        await chapterPage.close()
      }

    } catch (error) {
      chapterPage.off('request', onRequest)
      await chapterPage.close()
      await browser.close();

      if (error.name === 'TimeoutError') {
        throw new BotError('Failed to download chapter — page response timeout', error)
      }

      throw new BotError('Something went wrong and the chapter could not be downloaded', error)
    }
  }, {
    ...opt,
    chapterDownloadDelay: 2000,
  })

  // Fecha o navegador;
  await browser.close();

  return {
    title: novelInfo.title,
    author: novelInfo.author || [],
    status: novelInfo.status,
    thumbnail: novelInfo.thumbnail,
    chapters: chapters,
    description: novelInfo.description || [],
    genres: novelInfo.genres || [],
    language: LANGUAGE,
    source: SOURCE
  }
}