import { BotError } from './../../../errors/bot-error.ts';
import { puppeteerInstance } from "../../../lib/puppeteer.ts";
import { type DownloadNovelOptions, type IChapterData, type INovelData } from "../../../types/bot.ts";
import { logger } from '../../../utils/logger.ts';
import { processChaptersList } from '../../process-chapter-list.ts';
import { delay } from '../../../utils/delay.ts';
import { collectNovelInfo69shuba,  } from './parse-html/collect-novel-info.ts';
import { collectChapterList69shuba } from './parse-html/collect-chapter-list.ts';
import { collectChapter69shuba } from './parse-html/collect-chapter.ts';
import { ThumbnailProcessor } from '../../download-thumbnail.ts';

export const getNovel69shuba = async (
  url: string,
  opt: DownloadNovelOptions
): Promise<INovelData> => {


  const puppeteer = await puppeteerInstance();

  // instancia o browser
  const browser = await puppeteer.launch({
    headless: true,
    args: [
      '--no-sandbox',
      '--disable-setuid-sandbox',
      '--disable-dev-shm-usage',
      '--disable-gpu',
      '--no-zygote',
      '--disable-software-rasterizer',
      '--disable-features=VizDisplayCompositor'
    ],
    protocolTimeout: 60000 * 4,
  });
  const page = await browser.newPage();

  // Navega até a pagina alvo
  await page.goto(url, {
    waitUntil: 'load',
  });

  // Fica aguardando até que um titulo aparece na pagina
  await page.waitForSelector('h1');

  const novelInfo = await page.evaluate(collectNovelInfo69shuba);

  if (!novelInfo) {
    await browser.close()
    throw new BotError(
      'Unable to retrieve any information from the target page. Check if the URL used is correct'
    )
  }

  // download thumbnail To base64
  if(novelInfo.thumbnail){
    const thumbnailProcessor = new ThumbnailProcessor(novelInfo.thumbnail);
    const thumbnail = await thumbnailProcessor.execute();
    novelInfo.thumbnail = thumbnail;
  }
  

  // Check if list chapters url is collected
  if (!novelInfo.chapterListPageUrl) {
    await browser.close()
    throw new BotError('Unable to retrieve chapter list page url')
  }

  // Collect Chapter List
  await page.goto(novelInfo.chapterListPageUrl, { waitUntil: 'load' });
  const isCatalogPage = await page.waitForSelector('#catalog');

  if (!isCatalogPage) {
    await browser.close();
    throw new BotError('Unable to collect chapter list')
  }

  const chaptersList = await page.evaluate(collectChapterList69shuba);

  if (chaptersList.length === 0) {
    await browser.close();
    throw new BotError('The chapter list is empty, or it could not be retrieved')
  }


  // Collect Chapters
  const chapters: IChapterData[] = []
  await processChaptersList(chaptersList, async ({ url }, index) => {

    if (index % 100 === 0) {
      await delay(30000);
      logger.debug(`[DEBUG] Downloaded ${index} chapters. Waiting 30 seconds to avoid rate limits...`)
    }

    // Remove all cookies generated by site
    const cookies = await browser.cookies();
    await browser.deleteCookie(...cookies);

    try {
      await page.goto(url, { timeout: 60000, waitUntil: 'networkidle0' });
      const title = await page.waitForSelector('h1', { timeout: 10000 });

      if (!title) {
        await page.reload()
        await page.waitForSelector('h1', { timeout: 10000 })
      }

      const result = await page.evaluate(collectChapter69shuba);

      if(!result){
        throw new BotError('Failed to extract chapter')
      }


      chapters.push({
        title: result.title,
        content: result.content
      })

    } catch (error) {
      await browser.close();

      if (error.name === 'TimeoutError') {
        throw new BotError('Failed to download chapter — page response timeout', error)
      }

      throw new BotError('Something went wrong and the chapter could not be downloaded', error)
    }
  }, {
    ...opt,
    chapterDownloadDelay: 2000
  })



  // Fecha o navegador;
  await page.close()
  await browser.close();


  return {
    title: novelInfo.title,
    author: novelInfo.author || [],
    status: novelInfo.status,
    thumbnail: novelInfo.thumbnail,
    chapters: chapters,
    description: novelInfo.description || [],
    genres: novelInfo.genres || [],
    language: 'Chinese'
  }
}