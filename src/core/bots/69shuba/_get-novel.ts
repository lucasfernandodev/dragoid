import { downloadImage, processImageToBase64 } from './../../../utils/images.ts';
import { BotError } from './../../../errors/bot-error.ts';
import { puppeteerInstance } from "../../../lib/puppeteer.ts";
import { type DownloadNovelOptions, type IChapterData, type INovelData } from "../../../types/bot.ts";
import { logger } from '../../../utils/logger.ts';
import { processChaptersList } from '../../process-chapter-list.ts';
import { delay } from '../../../utils/delay.ts';
import { collectNovelInfo69shuba } from './parse-html/collect-novel-info.ts';



function collectPageData() {
  const description: string[] = []
  const title = document.querySelector(".booknav2 h1 a")?.textContent || null;
  const author = document.querySelectorAll(".booknav2 p a")[0]?.textContent || null;
  const descriptionText = document.querySelectorAll(".mybox .navtxt p");



  descriptionText?.forEach(paragrafo => {
    let linhaAtual = '';

    paragrafo.childNodes.forEach((node: any) => {
      if (node.nodeType === Node.ELEMENT_NODE && node.tagName === 'BR') {
        // Quando encontra um <br>, adiciona a linha atual ao array
        if (linhaAtual.trim()) {
          description.push(linhaAtual.trim());
        }
        linhaAtual = ''; // Reinicia a linha
      } else {
        // Adiciona o conteúdo de nós de texto ou outros elementos
        linhaAtual += node.textContent;
      }
    });

    // Adiciona a última linha se houver conteúdo restante
    if (linhaAtual.trim()) {
      description.push(linhaAtual.trim());
    }
  })

  const genres = Array.from(document.querySelectorAll(".booknav2 h1 p")).map(content => {
    return content?.textContent?.includes('分类：') ? content?.textContent.split('分类：')[1] : undefined
  }).filter(content => content !== undefined) as string[]

  const imageURL = document.querySelector(".bookimg2 img")?.getAttribute('src');


  const chaptersListUrl = document.querySelectorAll(".addbtn .btn")[0]?.getAttribute('href');

  if (!title && !author && genres.length === 0 && !imageURL && !chaptersListUrl) {
    return null;
  }

  return {
    title,
    author,
    genres,
    imageURL: chaptersListUrl ? imageURL : null,
    chaptersListUrl: chaptersListUrl ? chaptersListUrl : null,
    description
  }

}

function collectChapterList() {
  let chaptersList: { title: string, url: string }[] = []
  const links = Array.from(document.querySelectorAll('#catalog ul li a'));
  links.map(link => {
    chaptersList.push({
      url: link.getAttribute('href') as string,
      title: link.getAttribute('title') as string
    })
  })
  return chaptersList;
}

function collectChapter() {
  const title = document.querySelector('h1');
  const content = [] as string[];
  const container = document.querySelector(".txtnav");

  if (container) {
    container.childNodes.forEach(node => {
      if (node.nodeType === Node.TEXT_NODE) {
        const text = node?.textContent?.trim();
        if (text) content.push(text);
      }
    })
  }

  window.localStorage.clear();

  return {
    title: title?.textContent || '',
    content: content
  }
}

export const getNovel69shuba = async (
  url: string,
  opt: DownloadNovelOptions
): Promise<INovelData> => {

  const puppeteer = await puppeteerInstance();

  // instancia o browser
  const browser = await puppeteer.launch({
    headless: true,
    args: [
      '--no-sandbox',
      '--disable-setuid-sandbox',
      '--disable-dev-shm-usage',
      '--disable-gpu',
      '--no-zygote',
      '--disable-software-rasterizer',
      '--disable-features=VizDisplayCompositor'
    ],
    protocolTimeout: 60000 * 4,
  });
  const page = await browser.newPage();

  // Navega até a pagina alvo
  await page.goto(url, {
    waitUntil: 'load',
  });

  // Fica aguardando até que um titulo aparece na pagina
  await page.waitForSelector('h1');

  const novelInfo = await page.evaluate(collectNovelInfo69shuba);

  if (!novelInfo) {
    await browser.close()
    throw new BotError(
      'Unable to retrieve any information from the target page. Check if the URL used is correct'
    )
  }

  // Check if list chapters url is collected
  if (!novelInfo.chapterListPageUrl) {
    await browser.close()
    throw new BotError('Unable to retrieve chapter list page url')
  }

  // Collect Chapter List
  await page.goto(novelInfo.chapterListPageUrl, { waitUntil: 'load' });
  const isCatalogPage = await page.waitForSelector('#catalog');

  if (!isCatalogPage) {
    await browser.close();
    throw new BotError('Unable to collect chapter list')
  }

  const chaptersList = await page.evaluate(collectChapterList);



  // Collect Chapters
  const chapters: IChapterData[] = []
  await processChaptersList(chaptersList, async ({ url }, index) => {

    if (index % 100 === 0) {
      await delay(30000);
      logger.debug(`[DEBUG] Downloaded ${index} chapters. Waiting 30 seconds to avoid rate limits...`)
    }

    // Remove all cookies generated by site
    const cookies = await browser.cookies();
    await browser.deleteCookie(...cookies);

    try {
      await page.goto(url, { timeout: 60000, waitUntil: 'networkidle0' });
      const title = await page.waitForSelector('h1', { timeout: 10000 });

      if (!title) {
        await page.reload()
        await page.waitForSelector('h1', { timeout: 10000 })
      }

      const result = await page.evaluate(collectChapter);



      chapters.push({
        title: result.title,
        content: result.content
      })

    } catch (error) {
      await browser.close();

      if (error.name === 'TimeoutError') {
        throw new BotError('Failed to download chapter — page response timeout', error)
      }

      throw new BotError('Something went wrong and the chapter could not be downloaded', error)
    }
  }, {
    ...opt,
    chapterDownloadDelay: 2000
  })



  // Fecha o navegador;
  await page.close()
  await browser.close();

  const getImage = async (url?: string) => {
    if (!url) return '<image-url>'

    const bufferImage = await downloadImage(url);
    if (!bufferImage) {
      logger.warning('Novel thumbnail failed');
      return '<image-url>'
    }

    const base64Image = await processImageToBase64(bufferImage);
    if (!base64Image) return '<image-url>'

    return base64Image
  }


  return {
    title: novelInfo.title,
    author: novelInfo.author || [],
    status: novelInfo.status,
    thumbnail: await getImage(novelInfo.thumbnail),
    chapters: chapters,
    description: novelInfo.description || [],
    genres: novelInfo.genres || [],
    language: 'Chinese'
  }
}